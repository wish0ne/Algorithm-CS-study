## 시간제한

모두 시간제한이 1초일때

- N<500 이면 $O(N^3)$ 가능
- N<2000 이면 $O(N^2)$ 가능
- N<100,000이면 $O(NlogN)$ 가능
- N<10,000,000이면 $O(N)$ 가능

---

## Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법<br> <b>가장 큰 순서대로, 가장 작은 순서대로</b>

- 정렬 알고리즘과 자주 함께 출제됨.
- 그리디 알고리즘 문제에서는 문제풀이를 위한 최소한의 아이디어를 떠올리고, 이것이 정당한지 검토할 수 있어야 답을 도출가능.
- 문제유형을 파악하기 어렵다면 그리디를 의심하고, 고민해도 방법을 찾을 수 없다면 dp나 그래프 등을 고민해보기.
- 다익스트라 알고리즘과 크루스칼 알고리즘도 그리디 알고리즘에 속함.

---

## Implementation

> 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정.<br/>
> 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

#### 구현하기 어려운 문제

- 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
- 특정 소수점 자리까지 출력해야 하는 문제
- 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱) 문제

#### 구현 유형에 속하는 문제

- <b>완전탐색</b> : 모든 경우의 수를 빠짐없이 다 계산하는 해결방법
  - 모든 경우의 수를 계산하기 위해서 <strong>반복문 또는 재귀함수</strong>를 적절히 사용하여 예외케이스를 모두 확인해야하는 경우가 많음
  - 따라서 일반적으로 <strong>DFS/BFS 알고리즘</strong>을 이용해서 문제 해결
  - 시뮬레이션 역시 해결방법 유사
  - 원소를 나열하는 모든 경우의 수를 고려해야 하는 상황에서는 보통 <strong>순열이나 조합</strong> 사용
- <strong>시뮬레이션</strong> : 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행해야 하는 문제유형. 문제에서 제시하는 논리나 동작과정을 그대로 코드로 옮겨야한다.

### 구현 시 고려해야 할 메모리 제약 사항

- 정수형을 표현할때는 int 자료형을 사용하며 크기는 4byte
  - Number : $-2^{53}-1$ ~ $2^{53}-1$ 까지의 수
  - BigInt : Number의 안전 한계를 넘어서는 큰 정수도 안전하게 저장하고 연산 가능
- int 자료형 개수에 따른 메모리 사용량
  - 데이터 1,000개 일때 약 4KB 사용
  - 데이터 1,000,000개 일때 약 4MB 사용
  - 데이터 10,000,000개 일때 약 40MB 사용
- 크기가 10,000,000 이상인 배열이 있다면 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 존재 (하지만 드물다)
- 메모리 사용량 제한보다 더 적은 크기의 메모리를 사용해야 한다는 점만 기억

> 알고리즘 문제를 풀 때는 시간제한과 데이터의 개수를 먼저 확인한 뒤에 이 문제를 어느정도의 시간 복잡도 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.

---

## DFS/BFS

> <strong>탐색</strong> : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정 ex) DFS/BFS

- 1차원 배열이나 2차원 배열 역시 그래프 형태로 생각하면 쉽게 문제 풀 수 있음
- <strong>2차원 배열에서의 탐색문제를 그래프 형태로 바꿔서</strong> 생각하면 풀이방법을 쉽게 떠올릴 수 있음
- <strong>탐색 문제를 보면 그래프 형태로 표현</strong>한 다음 풀이법을 고민해보자

### 스택

> Firt In Last Out, Last In First Out

- array나 linked list 둘 중 아무거나 구현해도 상관없음
- array로 구현한 경우
  - 각 element들이 서로 연관되어 있기 때문에 속도가 더 빠름
  - 하지만 메모리 공간이 한정되어 있으므로 할당된 메모리를 다 사용하면 현재 배열을 다른곳으로 복사하기 때문에 메모리를 더 사용하게 될 수 있음
- linked list로 구현한 경우
  - 메모리에 여기저기 흩어져있기 때문에 상대적으로 느릴 수 있음
  - 반면 메모리 공간이 한정되어 있지 않고 얼마든지 값을 추가할 수 있음

### 큐

> First In First Out

- linked list로 만드는것이 좋음.
  - array의 경우 앞에서부터 element를 제거해야 하는데, 이때 제거 후 index를 재조정하기 때문에(나머지 원소들을 한 칸씩 당겨줘야함) O(N)이 걸림
  - linked list의 경우 O(1)로 해결가능

### 재귀함수

> 자기자신을 다시 호출하는 함수

- 재귀함수를 사용할때는 <strong>종료조건</strong>을 반드시 명시해야함.

* 컴퓨터 내부에서 재귀함수의 수행은 스택을 이용
  - 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수호출이 종료되기 때문
  - 연속해서 호출되는 함수는 메인메모리의 스택공간에 적재됨
  - 따라서 <strong>스택을 이용해야 하는 상당수의 알고리즘은 재귀를 통해 간편하게 구현가능</strong> ex) DFS

- 반복문보다 코드가 간결 (<strong>점화식</strong>을 그대로 코드로 옮기기 때문)
  - <strong>점화식이란 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것</strong>
  - 일반적으로 점화식에서 종료조건을 찾을 수 있다.

### 그래프 표현 방식

#### 인접행렬

> 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식

#### 인접리스트

> 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

- 메모리 측면에서 비교
  - 인접행렬은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 낭비
  - 인접리스트는 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
- 시간 측면에서 비교
  - 인접 리스트는 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림(연결된 데이터를 하나씩 확인해야함)
  - 모든 인접 노드를 순회해야하는 경우, 인접리스트가 메모리 공간 낭비가 적음

### DFS

> 깊이 우선 탐색. 그래프에서 최대한 멀리 있는 노드를 우선적으로 탐색하는 알고리즘

1. 탐색 시작 노드를 스택에 삽입하고 방문처리
2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면, 그 인접노드를 스택에 넣고 방문처리. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 2번의 과정을 더 이상 수행할 수 없을때까지 반복

- 스택 자료구조에 기초한다는 점에서 구현이 간단
- 데이터의 개수가 N개인 경우 O(N) 시간 소요
- 실제 구현은 재귀함수를 이용

### BFS

> 너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘

1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

- 큐 자료구조에 기초한다는 점에서 구현이 간단
- 탐색을 수행함에 있어 O(N)의 시간이 소요
- 일반적인 경우 수행시간은 DFS보다 좋은 편
- <strong>그래프에서 모든 간선의 비용이 동일할때는 BFS를 통해 최단거리 찾을 수 있음</strong>

---

## 정렬

> 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

- 데이터를 가공할 때 정렬해서 사용하는 경우가 많음
- 정렬은 <strong>이진 탐색의 전처리 과정</strong>
- 크루스칼 알고리즘에서도 간선의 정보를 정렬하는 과정 반드시 필요
- 문제 상황에 적절한 정렬 알고리즘을 사용하지 않으면 프로그램이 비효율적으로 동작, 시간 소요 큼

### 선택 정렬

> 가장 작은 데이터를 선택해 정렬되지 않은 데이터 중 가장 앞에 있는 데이터와 위치를 바꾸는 방법

- 가장 작은 데이터를 맨 앞으로 보내는 과정을 N-1번 반복
- 매번 가장 작은 수를 찾기 위한 비교 연산 필요
- 연산횟수는 $N + (N-1) + (N-2) + ... + 2$ -약 $(N^2 + N) / 2$이므로 시간복잡도는 $O(N^2)$
- 공간복잡도는 $O(N)$
- 데이터의 개수가 100배 늘어나면 수행시간은 10,000배로 늘어남
- 따라서 선택정렬을 이용하는 경우 데이터의 개수가 10,000개 이상이면 속도가 급격히 느려짐
- 다른 정렬 알고리즘에 비해 매우 비효율적
- 다만 배열에서 가장 작은 데이터를 찾는 일이 많으므로 소스코드에 익숙해지기

### 삽입 정렬

> 데이터를 앞에서부터 하나씩 확인하며 적절한 위치에 삽입

- 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어있다고 가정
- 정렬되어 있는 배열에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입됨
- 따라서 두번쨰 데이터부터 시작 (첫번째 데이터는 그 자체로 정렬됨)
- 앞의 데이터는 모두 정렬된 상태이므로 자기보다 작은 데이터를 만나면 더 살펴볼 필요없이 바로 그 자리에 삽입

<br/>

- 시간복잡도는 $O(N^2)$
- 필요할때만 위치를 바꾸므로 <strong>데이터가 거의 정렬되어 있을때</strong> 훨씬 효율적
- 정렬이 거의 되어있다면 퀵 정렬보다 효율적임
- 공간복잡도는 $O(N)$

### 퀵 정렬

> 기준을 설정하고, 그 기준보다 큰 데이터와 작은 데이터를 교환한 후 리스트를 반으로 나누는 방식

1. pivot 설정 (첫번째 데이터)
2. 왼쪽에서부터 pivot보다 큰 데이터를, 오른쪽에서부터 pivot보다 작은 데이터를 찾음
3. 큰 데이터와 작은 데이터의 위치를 교환
4. 2,3번을 반복하다가, 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 엇갈리면 작은데이터와 피벗의 위치를 교환 (분할 수행)
5. 분할된 왼쪽 리스트와 오른쪽 리스트를 개별적으로 퀵 정렬

- 평균 시간 복잡도는 $O(NlogN)$
- 최악의 경우 시간복잡도는 $O(N^2)$
- 데이터가 무작위로 입력되는 경우 빠르게 동작할 확률 높음
- 하지만 pivot을 가장 왼쪽 데이터로 잡을 때, <strong>이미 데이터가 정렬되어 있는 경우</strong>에서는 매우 느리게 동작
- 공간복잡도는 $O(N)$

### 계수 정렬

> 특정한 값을 가지는 데이터의 개수를 카운트하는 방법

- 데이터의 크기 범위가 제한되어 정수형태로 표현가능할때만 사용가능
- 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을때 효과적으로 사용가능 (차이가 너무 크면 사용불가)
- 모든 범위를 담을 수 있는 크기의 배열을 선언하고, 그 안에 정렬에 대한 정보를 담음

1. 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 배열을 생성
2. 배열의 모든 데이터가 0이 되도록 초기화
3. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가
4. 배열의 첫번째 데이터부터 하나씩 그 값만큼 인덱스를 출력

<br/>

#### 계수 정렬의 시간복잡도

- 데이터의 개수가 N, 데이터 중 최대값이 K일때 최악의 경우에도 $O(N+K)$를 보장
- 앞에서부터 데이터를 하나씩 확인 + 각 인덱스에 해당하는 값들을 확인할떄 데이터 중 최대값의 크기만큼 반복 수행
- 데이터의 범위만 한정되어 있다면 효과적으로 사용가능하며 항상 빠르게 동작

#### 계수 정렬의 공간복잡도

- 데이터가 0과 999,999 2개만 존재하더라도 배열의 크기가 100만개가 되도록 선언해야함 -> 심각한 비효율성 초래
- 따라서 동일한 값을 가지는 데이터가 여러 개 등장할때 적합
- 일반적인 공간복잡도는 공간복잡도는 $O(N+K)$
- 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 사용하는것이 유리

<br/>

> 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리

### 정렬 라이브러리

> 자바스크립트의 기본 정렬 라이브러리인 `sort()`

- 복잡도는 구현방식에 따라 다르다고 한다
- https://stackoverflow.com/questions/234683/javascript-array-sort-implementation
- https://stackoverflow.com/questions/57763205/what-is-array-prototype-sort-time-complexity
- 원 배열이 정렬됨. 복사본 만들어지는 것 아님

### 코딩테스트에서 정렬 알고리즘이 사용되는 경우

1. <strong>정렬 라이브러리로 풀 수 있는 문제</strong>: 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용방법을 숙지하고 있으면 풀 수 있음
2. <strong>정렬 알고리즘의 원리에 대해서 물어보는 문제</strong>: 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 풀 수 있음
3. <strong>더 빠른 정렬이 필요한 문제</strong>: 퀵 정렬 기반의 정렬기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나, 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있음

### 총정리

1. <strong>선택정렬</strong>: 아이디어가 매우 간단하나 매우 비효율적. 소스코드만 잘 이해하고 있기
2. <strong>삽입정렬</strong>: 데이터가 거의 정렬되어 있을때 가장 빠르므로 이때 사용하기
3. <strong>퀵 정렬</strong>: 대부분의 경우 가장 적합하지만, 데이터가 거의 정렬되어 있을때는 비효율적이므로 삽입정렬 사용하기
4. <strong>계수 정렬</strong>: 데이터의 크기가 한정되어 있는 경우에는 매우 빠르게 동작하므로 사용하기

---

## 소수의 판별

> 2보다 큰 자연수 중에서 1과 자기자신을 제외한 자연수로는 나누어떨어지지 않는 자연수

- 자연수의 약수가 가지는 특징 이용

  - 가운데 약수를 기준으로 해서 각 등식이 대칭적인 형태를 보임
  - 예를들어 16의 약수인 1,2,4,8,16에서 $2*8=16$과 $8*2=16$은 대칭
  - 따라서 가운데 약수까지만 나누어떨어지는지 확인하면됨(제곱근까지 = 4까지)
  - 이를 이용하면 시간복잡도 $O(X)$에서 $O(X^\frac{1}{2})$ 로 줄일 수 있다

- <b>하나의 수가 주어졌을때 그 수가 소수인지 아닌지 판별가능</b>
- 수의 범위가 주어졌을때, 그 범위안에 존재하는 모든 소수를 찾아야하는 경우와는 맞지 않는 알고리즘(느림) => <b>에라토스테네스의 체 이용</b>

---

## 에라토스테네스의 체

> 여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘<br/>
> N보다 작거나 같은 모든 소수를 찾을 때 사용가능

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾음
   (이때 i는 N의 제곱근(가운데 약수)까지만 증가시켜 확인하면됨)
3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않음)
4. 더이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복

- 시간복잡도는 $O(NloglogN)$으로 사실상 선형시간에 동작할 정도로 빠름
- 매우 빠르게 동작하지만 메모리가 많이 필요(N의 크기만큼 배열 할당)
- 따라서 에라토스테네스의 체를 이용해야하는 문제의 경우 N이 1,000,000이내로 주어지는 경우가 많음 => 4,000,000번 정도의 연산으로 문제 해결 가능 & 메모리 또한 충분
