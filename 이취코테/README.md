## 시간제한

모두 시간제한이 1초일때

- N<500 이면 $O(N^3)$ 가능
- N<2000 이면 $O(N^2)$ 가능
- N<100,000이면 $O(NlogN)$ 가능
- N<10,000,000이면 $O(N)$ 가능

---

## Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법<br> <b>가장 큰 순서대로, 가장 작은 순서대로</b>

- 정렬 알고리즘과 자주 함께 출제됨.
- 그리디 알고리즘 문제에서는 문제풀이를 위한 최소한의 아이디어를 떠올리고, 이것이 정당한지 검토할 수 있어야 답을 도출가능.
- 문제유형을 파악하기 어렵다면 그리디를 의심하고, 고민해도 방법을 찾을 수 없다면 dp나 그래프 등을 고민해보기.
- 다익스트라 알고리즘과 크루스칼 알고리즘도 그리디 알고리즘에 속함.

---

## Implementation

> 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정.<br/>
> 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

#### 구현하기 어려운 문제

- 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
- 특정 소수점 자리까지 출력해야 하는 문제
- 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱) 문제

#### 구현 유형에 속하는 문제

- <b>완전탐색</b> : 모든 경우의 수를 빠짐없이 다 계산하는 해결방법
  - 모든 경우의 수를 계산하기 위해서 <strong>반복문 또는 재귀함수</strong>를 적절히 사용하여 예외케이스를 모두 확인해야하는 경우가 많음
  - 따라서 일반적으로 <strong>DFS/BFS 알고리즘</strong>을 이용해서 문제 해결
  - 시뮬레이션 역시 해결방법 유사
  - 원소를 나열하는 모든 경우의 수를 고려해야 하는 상황에서는 보통 <strong>순열이나 조합</strong> 사용
- <strong>시뮬레이션</strong> : 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행해야 하는 문제유형. 문제에서 제시하는 논리나 동작과정을 그대로 코드로 옮겨야한다.

### 구현 시 고려해야 할 메모리 제약 사항

- 정수형을 표현할때는 int 자료형을 사용하며 크기는 4byte
  - Number : $-2^{53}-1$ ~ $2^{53}-1$ 까지의 수
  - BigInt : Number의 안전 한계를 넘어서는 큰 정수도 안전하게 저장하고 연산 가능
- int 자료형 개수에 따른 메모리 사용량
  - 데이터 1,000개 일때 약 4KB 사용
  - 데이터 1,000,000개 일때 약 4MB 사용
  - 데이터 10,000,000개 일때 약 40MB 사용
- 크기가 10,000,000 이상인 배열이 있다면 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 존재 (하지만 드물다)
- 메모리 사용량 제한보다 더 적은 크기의 메모리를 사용해야 한다는 점만 기억

> 알고리즘 문제를 풀 때는 시간제한과 데이터의 개수를 먼저 확인한 뒤에 이 문제를 어느정도의 시간 복잡도 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.

---

## DFS/BFS

> <strong>탐색</strong> : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정 ex) DFS/BFS

- 1차원 배열이나 2차원 배열 역시 그래프 형태로 생각하면 쉽게 문제 풀 수 있음
- <strong>2차원 배열에서의 탐색문제를 그래프 형태로 바꿔서</strong> 생각하면 풀이방법을 쉽게 떠올릴 수 있음
- <strong>탐색 문제를 보면 그래프 형태로 표현</strong>한 다음 풀이법을 고민해보자

### 스택

> Firt In Last Out, Last In First Out

- array나 linked list 둘 중 아무거나 구현해도 상관없음
- array로 구현한 경우
  - 각 element들이 서로 연관되어 있기 때문에 속도가 더 빠름
  - 하지만 메모리 공간이 한정되어 있으므로 할당된 메모리를 다 사용하면 현재 배열을 다른곳으로 복사하기 때문에 메모리를 더 사용하게 될 수 있음
- linked list로 구현한 경우
  - 메모리에 여기저기 흩어져있기 때문에 상대적으로 느릴 수 있음
  - 반면 메모리 공간이 한정되어 있지 않고 얼마든지 값을 추가할 수 있음

### 큐

> First In First Out

- linked list로 만드는것이 좋음.
  - array의 경우 앞에서부터 element를 제거해야 하는데, 이때 제거 후 index를 재조정하기 때문에(나머지 원소들을 한 칸씩 당겨줘야함) O(N)이 걸림
  - linked list의 경우 O(1)로 해결가능

### 재귀함수

> 자기자신을 다시 호출하는 함수

- 재귀함수를 사용할때는 <strong>종료조건</strong>을 반드시 명시해야함.

* 컴퓨터 내부에서 재귀함수의 수행은 스택을 이용
  - 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수호출이 종료되기 때문
  - 연속해서 호출되는 함수는 메인메모리의 스택공간에 적재됨
  - 따라서 <strong>스택을 이용해야 하는 상당수의 알고리즘은 재귀를 통해 간편하게 구현가능</strong> ex) DFS

- 반복문보다 코드가 간결 (<strong>점화식</strong>을 그대로 코드로 옮기기 때문)
  - <strong>점화식이란 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것</strong>
  - 일반적으로 점화식에서 종료조건을 찾을 수 있다.

### 그래프 표현 방식

#### 인접행렬

> 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식

#### 인접리스트

> 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

- 메모리 측면에서 비교
  - 인접행렬은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 낭비
  - 인접리스트는 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
- 시간 측면에서 비교
  - 인접 리스트는 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림(연결된 데이터를 하나씩 확인해야함)
  - 모든 인접 노드를 순회해야하는 경우, 인접리스트가 메모리 공간 낭비가 적음

### DFS

> 깊이 우선 탐색. 그래프에서 최대한 멀리 있는 노드를 우선적으로 탐색하는 알고리즘

1. 탐색 시작 노드를 스택에 삽입하고 방문처리
2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면, 그 인접노드를 스택에 넣고 방문처리. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 2번의 과정을 더 이상 수행할 수 없을때까지 반복

- 스택 자료구조에 기초한다는 점에서 구현이 간단
- 데이터의 개수가 N개인 경우 O(N) 시간 소요
- 실제 구현은 재귀함수를 이용

### BFS

> 너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘

1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

- 큐 자료구조에 기초한다는 점에서 구현이 간단
- 탐색을 수행함에 있어 O(N)의 시간이 소요
- 일반적인 경우 수행시간은 DFS보다 좋은 편
- <strong>그래프에서 모든 간선의 비용이 동일할때는 BFS를 통해 최단거리 찾을 수 있음</strong>

---

## 소수의 판별

> 2보다 큰 자연수 중에서 1과 자기자신을 제외한 자연수로는 나누어떨어지지 않는 자연수

- 자연수의 약수가 가지는 특징 이용

  - 가운데 약수를 기준으로 해서 각 등식이 대칭적인 형태를 보임
  - 예를들어 16의 약수인 1,2,4,8,16에서 $2*8=16$과 $8*2=16$은 대칭
  - 따라서 가운데 약수까지만 나누어떨어지는지 확인하면됨(제곱근까지 = 4까지)
  - 이를 이용하면 시간복잡도 $O(X)$에서 $O(X^\frac{1}{2})$ 로 줄일 수 있다

- <b>하나의 수가 주어졌을때 그 수가 소수인지 아닌지 판별가능</b>
- 수의 범위가 주어졌을때, 그 범위안에 존재하는 모든 소수를 찾아야하는 경우와는 맞지 않는 알고리즘(느림) => <b>에라토스테네스의 체 이용</b>

---

## 에라토스테네스의 체

> 여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘<br/>
> N보다 작거나 같은 모든 소수를 찾을 때 사용가능

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾음
   (이때 i는 N의 제곱근(가운데 약수)까지만 증가시켜 확인하면됨)
3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않음)
4. 더이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복

- 시간복잡도는 $O(NloglogN)$으로 사실상 선형시간에 동작할 정도로 빠름
- 매우 빠르게 동작하지만 메모리가 많이 필요(N의 크기만큼 배열 할당)
- 따라서 에라토스테네스의 체를 이용해야하는 문제의 경우 N이 1,000,000이내로 주어지는 경우가 많음 => 4,000,000번 정도의 연산으로 문제 해결 가능 & 메모리 또한 충분
