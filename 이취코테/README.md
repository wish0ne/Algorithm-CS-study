## 시간제한

모두 시간제한이 1초일때

- N<500 이면 $O(N^3)$ 가능
- N<2000 이면 $O(N^2)$ 가능
- N<100,000이면 $O(NlogN)$ 가능
- N<10,000,000이면 $O(N)$ 가능

---

## Greedy

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법<br> <b>가장 큰 순서대로, 가장 작은 순서대로</b>

- 정렬 알고리즘과 자주 함께 출제됨.
- 그리디 알고리즘 문제에서는 문제풀이를 위한 최소한의 아이디어를 떠올리고, 이것이 정당한지 검토할 수 있어야 답을 도출가능.
- 문제유형을 파악하기 어렵다면 그리디를 의심하고, 고민해도 방법을 찾을 수 없다면 dp나 그래프 등을 고민해보기.
- 다익스트라 알고리즘과 크루스칼 알고리즘도 그리디 알고리즘에 속함.

---

## Implementation

> 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정.<br/>
> 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

#### 구현하기 어려운 문제

- 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
- 특정 소수점 자리까지 출력해야 하는 문제
- 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱) 문제

#### 구현 유형에 속하는 문제

- <b>완전탐색</b> : 모든 경우의 수를 빠짐없이 다 계산하는 해결방법
  - 모든 경우의 수를 계산하기 위해서 <strong>반복문 또는 재귀함수</strong>를 적절히 사용하여 예외케이스를 모두 확인해야하는 경우가 많음
  - 따라서 일반적으로 <strong>DFS/BFS 알고리즘</strong>을 이용해서 문제 해결
  - 시뮬레이션 역시 해결방법 유사
  - 원소를 나열하는 모든 경우의 수를 고려해야 하는 상황에서는 보통 <strong>순열이나 조합</strong> 사용
- <strong>시뮬레이션</strong> : 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행해야 하는 문제유형. 문제에서 제시하는 논리나 동작과정을 그대로 코드로 옮겨야한다.

### 구현 시 고려해야 할 메모리 제약 사항

- 정수형을 표현할때는 int 자료형을 사용하며 크기는 4byte
  - Number : $-2^{53}-1$ ~ $2^{53}-1$ 까지의 수
  - BigInt : Number의 안전 한계를 넘어서는 큰 정수도 안전하게 저장하고 연산 가능
- int 자료형 개수에 따른 메모리 사용량
  - 데이터 1,000개 일때 약 4KB 사용
  - 데이터 1,000,000개 일때 약 4MB 사용
  - 데이터 10,000,000개 일때 약 40MB 사용
- 크기가 10,000,000 이상인 배열이 있다면 메모리 용량 제한으로 문제를 풀 수 없게 되는 경우도 존재 (하지만 드물다)
- 메모리 사용량 제한보다 더 적은 크기의 메모리를 사용해야 한다는 점만 기억

> 알고리즘 문제를 풀 때는 시간제한과 데이터의 개수를 먼저 확인한 뒤에 이 문제를 어느정도의 시간 복잡도 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.

---

## DFS/BFS

> <strong>탐색</strong> : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정 ex) DFS/BFS

- 1차원 배열이나 2차원 배열 역시 그래프 형태로 생각하면 쉽게 문제 풀 수 있음
- <strong>2차원 배열에서의 탐색문제를 그래프 형태로 바꿔서</strong> 생각하면 풀이방법을 쉽게 떠올릴 수 있음
- <strong>탐색 문제를 보면 그래프 형태로 표현</strong>한 다음 풀이법을 고민해보자

### 스택

> Firt In Last Out, Last In First Out

- array나 linked list 둘 중 아무거나 구현해도 상관없음
- array로 구현한 경우
  - 각 element들이 서로 연관되어 있기 때문에 속도가 더 빠름
  - 하지만 메모리 공간이 한정되어 있으므로 할당된 메모리를 다 사용하면 현재 배열을 다른곳으로 복사하기 때문에 메모리를 더 사용하게 될 수 있음
- linked list로 구현한 경우
  - 메모리에 여기저기 흩어져있기 때문에 상대적으로 느릴 수 있음
  - 반면 메모리 공간이 한정되어 있지 않고 얼마든지 값을 추가할 수 있음

### 큐

> First In First Out

- linked list로 만드는것이 좋음.
  - array의 경우 앞에서부터 element를 제거해야 하는데, 이때 제거 후 index를 재조정하기 때문에(나머지 원소들을 한 칸씩 당겨줘야함) O(N)이 걸림
  - linked list의 경우 O(1)로 해결가능

### 재귀함수

> 자기자신을 다시 호출하는 함수

- 재귀함수를 사용할때는 <strong>종료조건</strong>을 반드시 명시해야함.

* 컴퓨터 내부에서 재귀함수의 수행은 스택을 이용
  - 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수호출이 종료되기 때문
  - 연속해서 호출되는 함수는 메인메모리의 스택공간에 적재됨
  - 따라서 <strong>스택을 이용해야 하는 상당수의 알고리즘은 재귀를 통해 간편하게 구현가능</strong> ex) DFS

- 반복문보다 코드가 간결 (<strong>점화식</strong>을 그대로 코드로 옮기기 때문)
  - <strong>점화식이란 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것</strong>
  - 일반적으로 점화식에서 종료조건을 찾을 수 있다.

### 그래프 표현 방식

#### 인접행렬

> 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식

#### 인접리스트

> 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

- 메모리 측면에서 비교
  - 인접행렬은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 낭비
  - 인접리스트는 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용
- 시간 측면에서 비교
  - 인접 리스트는 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림(연결된 데이터를 하나씩 확인해야함)
  - 모든 인접 노드를 순회해야하는 경우, 인접리스트가 메모리 공간 낭비가 적음

### DFS

> 깊이 우선 탐색. 그래프에서 최대한 멀리 있는 노드를 우선적으로 탐색하는 알고리즘

1. 탐색 시작 노드를 스택에 삽입하고 방문처리
2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면, 그 인접노드를 스택에 넣고 방문처리. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄
3. 2번의 과정을 더 이상 수행할 수 없을때까지 반복

- 스택 자료구조에 기초한다는 점에서 구현이 간단
- 데이터의 개수가 N개인 경우 O(N) 시간 소요
- 실제 구현은 재귀함수를 이용

### BFS

> 너비 우선 탐색. 가까운 노드부터 탐색하는 알고리즘

1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

- 큐 자료구조에 기초한다는 점에서 구현이 간단
- 탐색을 수행함에 있어 O(N)의 시간이 소요
- 일반적인 경우 수행시간은 DFS보다 좋은 편
- <strong>그래프에서 모든 간선의 비용이 동일할때는 BFS를 통해 최단거리 찾을 수 있음</strong>

---

## 정렬

> 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

- 데이터를 가공할 때 정렬해서 사용하는 경우가 많음
- 정렬은 <strong>이진 탐색의 전처리 과정</strong>
- 크루스칼 알고리즘에서도 간선의 정보를 정렬하는 과정 반드시 필요
- 문제 상황에 적절한 정렬 알고리즘을 사용하지 않으면 프로그램이 비효율적으로 동작, 시간 소요 큼

### 선택 정렬

> 가장 작은 데이터를 선택해 정렬되지 않은 데이터 중 가장 앞에 있는 데이터와 위치를 바꾸는 방법

- 가장 작은 데이터를 맨 앞으로 보내는 과정을 N-1번 반복
- 매번 가장 작은 수를 찾기 위한 비교 연산 필요
- 연산횟수는 $N + (N-1) + (N-2) + ... + 2$ -약 $(N^2 + N) / 2$이므로 시간복잡도는 $O(N^2)$
- 공간복잡도는 $O(N)$
- 데이터의 개수가 100배 늘어나면 수행시간은 10,000배로 늘어남
- 따라서 선택정렬을 이용하는 경우 데이터의 개수가 10,000개 이상이면 속도가 급격히 느려짐
- 다른 정렬 알고리즘에 비해 매우 비효율적
- 다만 배열에서 가장 작은 데이터를 찾는 일이 많으므로 소스코드에 익숙해지기

### 삽입 정렬

> 데이터를 앞에서부터 하나씩 확인하며 적절한 위치에 삽입

- 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어있다고 가정
- 정렬되어 있는 배열에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입됨
- 따라서 두번쨰 데이터부터 시작 (첫번째 데이터는 그 자체로 정렬됨)
- 앞의 데이터는 모두 정렬된 상태이므로 자기보다 작은 데이터를 만나면 더 살펴볼 필요없이 바로 그 자리에 삽입

<br/>

- 시간복잡도는 $O(N^2)$
- 필요할때만 위치를 바꾸므로 <strong>데이터가 거의 정렬되어 있을때</strong> 훨씬 효율적
- 정렬이 거의 되어있다면 퀵 정렬보다 효율적임
- 공간복잡도는 $O(N)$

### 퀵 정렬

> 기준을 설정하고, 그 기준보다 큰 데이터와 작은 데이터를 교환한 후 리스트를 반으로 나누는 방식

1. pivot 설정 (첫번째 데이터)
2. 왼쪽에서부터 pivot보다 큰 데이터를, 오른쪽에서부터 pivot보다 작은 데이터를 찾음
3. 큰 데이터와 작은 데이터의 위치를 교환
4. 2,3번을 반복하다가, 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 엇갈리면 작은데이터와 피벗의 위치를 교환 (분할 수행)
5. 분할된 왼쪽 리스트와 오른쪽 리스트를 개별적으로 퀵 정렬

- 평균 시간 복잡도는 $O(NlogN)$
- 최악의 경우 시간복잡도는 $O(N^2)$
- 데이터가 무작위로 입력되는 경우 빠르게 동작할 확률 높음
- 하지만 pivot을 가장 왼쪽 데이터로 잡을 때, <strong>이미 데이터가 정렬되어 있는 경우</strong>에서는 매우 느리게 동작
- 공간복잡도는 $O(N)$

### 계수 정렬

> 특정한 값을 가지는 데이터의 개수를 카운트하는 방법

- 데이터의 크기 범위가 제한되어 정수형태로 표현가능할때만 사용가능
- 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을때 효과적으로 사용가능 (차이가 너무 크면 사용불가)
- 모든 범위를 담을 수 있는 크기의 배열을 선언하고, 그 안에 정렬에 대한 정보를 담음

1. 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 배열을 생성
2. 배열의 모든 데이터가 0이 되도록 초기화
3. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가
4. 배열의 첫번째 데이터부터 하나씩 그 값만큼 인덱스를 출력

<br/>

#### 계수 정렬의 시간복잡도

- 데이터의 개수가 N, 데이터 중 최대값이 K일때 최악의 경우에도 $O(N+K)$를 보장
- 앞에서부터 데이터를 하나씩 확인 + 각 인덱스에 해당하는 값들을 확인할떄 데이터 중 최대값의 크기만큼 반복 수행
- 데이터의 범위만 한정되어 있다면 효과적으로 사용가능하며 항상 빠르게 동작

#### 계수 정렬의 공간복잡도

- 데이터가 0과 999,999 2개만 존재하더라도 배열의 크기가 100만개가 되도록 선언해야함 -> 심각한 비효율성 초래
- 따라서 동일한 값을 가지는 데이터가 여러 개 등장할때 적합
- 일반적인 공간복잡도는 공간복잡도는 $O(N+K)$
- 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 사용하는것이 유리

<br/>

> 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리

### 정렬 라이브러리

> 자바스크립트의 기본 정렬 라이브러리인 `sort()`

- 복잡도는 구현방식에 따라 다르다고 한다
- https://stackoverflow.com/questions/234683/javascript-array-sort-implementation
- https://stackoverflow.com/questions/57763205/what-is-array-prototype-sort-time-complexity
- 원 배열이 정렬됨. 복사본 만들어지는 것 아님

### 코딩테스트에서 정렬 알고리즘이 사용되는 경우

1. <strong>정렬 라이브러리로 풀 수 있는 문제</strong>: 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용방법을 숙지하고 있으면 풀 수 있음
2. <strong>정렬 알고리즘의 원리에 대해서 물어보는 문제</strong>: 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 풀 수 있음
3. <strong>더 빠른 정렬이 필요한 문제</strong>: 퀵 정렬 기반의 정렬기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나, 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있음

### 총정리

1. <strong>선택정렬</strong>: 아이디어가 매우 간단하나 매우 비효율적. 소스코드만 잘 이해하고 있기
2. <strong>삽입정렬</strong>: 데이터가 거의 정렬되어 있을때 가장 빠르므로 이때 사용하기
3. <strong>퀵 정렬</strong>: 대부분의 경우 가장 적합하지만, 데이터가 거의 정렬되어 있을때는 비효율적이므로 삽입정렬 사용하기
4. <strong>계수 정렬</strong>: 데이터의 크기가 한정되어 있는 경우에는 매우 빠르게 동작하므로 사용하기

---

## 이진 탐색

### 순차 탐색

> 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법

- 보통 정렬되지 않은 리스트에서 데이터를 찾을 때 사용
- 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 데이터를 찾을 수 있다는 장점
- 리스트의 데이터에 하나씩 방문하며 같은지 검사하므로 구현도 간단
- 시간복잡도 $O(N)$

### 이진 탐색

> 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 방법

- 데이터가 이미 정렬되어 있어야만 사용가능
- 탐색범위를 절반씩 좁혀가며 탐색
- 위치를 나타내는 변수 3개 사용 : 시작점, 끝점, 중간점
- 한번 확인할때마다 확인하는 원소의 개수가 절반씩 줄어듦 : 시간복잡도 $O(logN)$

#### 코딩테스트에서의 이진탐색

> 이진 탐색 코드는 반복하면서 외워두자

이진탐색은 다른 알고리즘과 함께 사용되는 경우가 많으므로 매우 중요하다. 이때 이진탐색 코드만 암기하고 있더라도 큰 도움이 된다.
<br/>

또한 코딩테스트에서 이진탐색문제는 탐색범위가 큰 상황에서의 탐색을 가정하는 문제가 많다.
따라서 <strong>탐색범위가 2,000만을 넘어가면 이진탐색으로 접근</strong>해보자.
처리해야할 데이터의 개수가 1,000만 단위 이상으로 넘어가면 이진탐색과 같이 $O(logN)$의 속도를 내야하는 알고리즘을 떠올려야 문제를 풀 수 있다!

### 트리 자료구조

> 노드와 노드의 연결로 표현

- 노드 : 정보의 단위. 어떠한 정보를 가지고 있는 개체
- 트리 자료구조는 그래프 자료구조의 일종으로 DB 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용

#### 트리 자료구조의 특징

- 트리는 부모 노드와 자식 노드의 관계로 표현됨
- 트리의 최상단 노드는 루트 노드
- 트리의 최하단 노드는 단말 노드
- 트리에서 일부를 떼어내도 트리 구조이며 이를 서브트리라고 함
- 트리는 파일시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합

큰 데이터를 처리하는 소프트웨어는 대부분 데이터를 트리 자료구조로 저장해서 이진탐색과 같은 탐색기법을 사용해 빠르게 탐색이 가능하다.

### 이진 탐색 트리

> 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조

#### 이진 탐색 트리의 특징

- 부모 노드보다 왼쪽 자식 노드가 작다
- 부모 노드보다 오른쪽 자식 노드가 크다
  > 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드

### 파라메트릭 서치

> 최적화 문제를 결정 문제로 바꾸어 해결하는 기법

<strong>원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제</strong>에 주로 파라메트릭 서치를 사용한다.

- 결정 문제 : 예 혹은 아니오로 답하는 문제
- 보통 파라메트릭 서치 유형은 이진 탐색을 이용하여 해결
- 파라메트릭 서치 유형은 <strong>이진탐색을 반복문으로 구현</strong>하면 더 간결하게 해결 가능

---

## 다이나믹 프로그래밍

> 한 번 해결된 부분 문제의 정답을 메모리에 기록하여, 한 번 계산한 답은 다시 계산하지 않도록 하는 문제 해결 기법

- 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시킬 수 있는 방법
- 다이나믹 프로그래밍은 <strong>점화식을 그대로 코드로 옮겨서</strong> 구현가능

#### 다이나믹 프로그래밍을 사용할 수 있는 조건

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

큰 문제를 작게 나누고, 같은 문제라면 한번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

### 메모이제이션

> 다이나믹 프로그래밍 구현 방법 중 하나. <strong>한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법.</strong> 캐싱이라고도 함.

한번 구한 정보를 배열에 저장함으로써 메모이제이션 구현 가능.
다이나믹 프로그래밍을 재귀적으로 수행하다가같은 정보가 필요할때는 배열에서 가져오면 됨.

#### 분할정복과 DP의 차이

> DP는 문제들이 서로 영향을 미치고 있음

- 퀵 정렬에서 pivot이 한번 정해지면 pivot의 위치는 변하지 않고 그 pivot값을 다시 처리하는 부분문제는 존재하지 않음.
- 반면 DP는 한 번 해결한 문제를 다시 해결한다는 점이 특징
- 따라서 이미 해결된 부분 문제에 대한 답을 저장해 놓고, 이 문제는 다시 해결할 필요가 없으니 답을 반환하는것.

### Top-Down 방식(메모이제이션, 하향식)

> 재귀함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법

큰 문제를 해결하기 위해 작은 문제를 호출함.

- 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현
- 수열은 배열로 표현 가능
- 메모이제이션은 때에 따라서 사전 자료형같은 다른 자료형 사용 가능
- 사전 자료형은 수열처럼 연속적이지 않은 경우에 유용

### Bottom-Up 방식(상향식)

> 반복문을 이용하여 소스코드를 작성하는 경우

작은 문제부터 차근차근 답을 도출함.

- 재귀함수 대신 반복문을 이용한 DP가 일반적으로 더 성능이 좋음 (재귀 함수는 오버헤드 발생)
- DP의 전형적인 형태
- 상향식에서 사용되는 결과 저장용 리스트를 <strong>DP 테이블</strong>이라 한다.

### 다이나믹 프로그래밍 문제를 푸는 방법

1. 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는것.
   - 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 DP를 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자.
2. 일단 단순히 재귀 함수로 비효율적인 프로그래밍을 작성한 뒤(탑다운) 작은 문제에서 구한 답이 큰 문제에서 사용될 수 있으면(메모이제이션 적용가능하면) 코드를 개선하는 것도 좋은 아이디어
3. 가능하다면 재귀함수를 이용하는 탑다운 방식보다는 바텀업 방식으로 구현하는 것을 권장.
   - 시스템 상 재귀함수의 스택 크기가 한정되어 있을 수 있음

---

## 최단경로

> 가장 짧은 경로를 찾는 알고리즘

- 최단경로문제는 보통 그래프를 이용해 표현
  - 각 지점은 노드, 지점간 연결된 도로는 간선으로 표현

### 다익스트라 최단 경로 알고리즘

> 한 지점에서 다른 모든 지점까지의 최단 경로를 계산

1. 출발 노드를 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
5. 3, 4번을 반복

- 음의 간선이 없을때 정상적으로 동작
- 그리디 알고리즘으로 분류 (매번 가장 비용이 적은 노드를 선택해서 임의의 과정을 반복)
- 각 노드에 대한 현재까지의 최단거리 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신
- 다익스트라 코드는 암기해둬야함

방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택하는 과정을 반복하는데, 이렇게 <strong>선택된 노드는 최단거리가 완전히 선택된 노드</strong>이므로 더이상 알고리즘을 반복해도 최단거리가 줄어들지 않는다.

즉 다익스트라 알고리즘이 진행되면서 <strong>한 단계당 하나의 노드에 대한 최단거리를 확실히 찾는 것</strong>

#### Heap

<strong>우선순위 큐</strong>를 구현하기 위해 사용하는 자료구조 중 하나.

#### 우선순위 큐

> 데이터를 우선순위에 따라 처리. 우선순위가 가장 높은 데이터를 먼저 삭제

- 대부분 데이터의 묶음 중에서 첫번째 원소를 기준으로 우선순위를 설정
- 우선순위 큐를 구현할때는 내부적으로 최소힙 또는 최대힙을 이용
- 다익스트라에서는 비용이 적은 노드를 먼저 방문하므로 최소힙 기반 우선순위 큐를 사용하면 적합
- 최소힙을 최대힙처럼 사용하기 위해 우선순위에 해당하는 값에 음수 부호(-)를 붙여 넣었다가, 우선순위큐에서 꺼낸 다음 다시 -를 붙여 원래 값으로 돌리는 방식 사용가능
- 우선순위큐는 힙말고 단순히 리스트를 이용해서도 구현가능
  - 리스트로 구현한 우선순위 큐 : 삽입 $O(1)$, 삭제 $O(N)$
  - 힙으로 구현한 우선순위 큐 : 삽입 $O(logN)$, 삭제 $O(logN)$

#### Heap으로 다익스트라 알고리즘 구현

- 시작노드로부터 거리가 짧은 노드 순서대로 우선순위 큐에서 나올 수 있도록 구현
- 최악의 경우에도 시간복잡도 $O(ElogV)$보장 (E : 간선의 개수, V : 노드의 개수)
- 우선순위 큐를 필요로 하는 다른 문제 유형과도 흡사함. 따라서 최단 경로를 찾는 문제를 제외하고도 다른 문제에도 두루 적용되는 소스코드 형태이므로 (ex 최소 신장 트리 문제의 Prim 알고리즘의 구현이 다익스트라의 구현과 흡사) 다익스트라 알고리즘을 잘 이해하고 암기하는것이 좋음

### 플로이드 워셜 알고리즘

> 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우에 사용할 수 있는 알고리즘

- 노드의 개수가 N개일때 알고리즘 상으로 N번의 단계를 수행하며 단계마다 $O(N^2)$의 연산을 통해 현재 노드를 거쳐가는 모든 경로를 고려 => 총 시간 복잡도는 $O(N^3)$
- 2차원 배열에 최단거리 정보를 저장
- 다이나믹 프로그래밍에 해당. N번만큼 단계를 반복하며 점화식에 맞게 2차원 배열을 갱신하기 때문
- 각 단계에서는 해당 노드를 거쳐가는 경우를 고려
  - 현재 노드를 제외한 N-1개의 노드 중에서 서로 다른 노드 (A,B)쌍을 선택하고 A->현재노드->B로 가는 비용을 확인한 뒤 최단거리를 갱신
- 점화식 : A에서 B로 가는 최소비용과 A에서 K를 거쳐 B로 가는 비용을 비교하여 더 작은 값으로 갱신
- 즉 바로 이동하는 거리가 특정한 노드를 거쳐서 이동하는 거리보다 더 많은 비용을 가진다면 더 짧은 것으로 갱신

> 코딩테스트에서는 겉보기에 최단 경로 문제처럼 보이지 않더라도 최소 비용을 구해야하는 다양한 문제에 최단 경로 알고리즘을 적용할 수 있다.

---

## 소수의 판별

> 2보다 큰 자연수 중에서 1과 자기자신을 제외한 자연수로는 나누어떨어지지 않는 자연수

- 자연수의 약수가 가지는 특징 이용

  - 가운데 약수를 기준으로 해서 각 등식이 대칭적인 형태를 보임
  - 예를들어 16의 약수인 1,2,4,8,16에서 $2*8=16$과 $8*2=16$은 대칭
  - 따라서 가운데 약수까지만 나누어떨어지는지 확인하면됨(제곱근까지 = 4까지)
  - 이를 이용하면 시간복잡도 $O(X)$에서 $O(X^\frac{1}{2})$ 로 줄일 수 있다

- <b>하나의 수가 주어졌을때 그 수가 소수인지 아닌지 판별가능</b>
- 수의 범위가 주어졌을때, 그 범위안에 존재하는 모든 소수를 찾아야하는 경우와는 맞지 않는 알고리즘(느림) => <b>에라토스테네스의 체 이용</b>

---

## 에라토스테네스의 체

> 여러 개의 수가 소수인지 아닌지를 판별할 때 사용하는 대표적인 알고리즘<br/>
> N보다 작거나 같은 모든 소수를 찾을 때 사용가능

1. 2부터 N까지의 모든 자연수를 나열
2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾음
   (이때 i는 N의 제곱근(가운데 약수)까지만 증가시켜 확인하면됨)
3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않음)
4. 더이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복

- 시간복잡도는 $O(NloglogN)$으로 사실상 선형시간에 동작할 정도로 빠름
- 매우 빠르게 동작하지만 메모리가 많이 필요(N의 크기만큼 배열 할당)
- 따라서 에라토스테네스의 체를 이용해야하는 문제의 경우 N이 1,000,000이내로 주어지는 경우가 많음 => 4,000,000번 정도의 연산으로 문제 해결 가능 & 메모리 또한 충분

---

## 투 포인터

> 리스트에 순차적으로 접근해야 할 때 2개의 점의 위치를 기록하면서 처리하는 알고리즘

리스트에 담긴 데이터에 순차적으로 접근해야 할때는 '시작점'과 '끝점' 2개의 점으로 접근할 데이터의 범위를 표현가능

### 특정한 합을 가지는 부분 연속 수열 찾기

> 양의 정수로만 구성된 리스트가 주어졌을 때, 그 부분 연속 수열 중에서 '특정한 합'을 갖는 수열의 개수를 출력하는 문제

1. 시작점 start와 끝점 end가 첫번째 원소의 인덱스(0)을 가리키도록 한다.
2. 현재 부분합이 M과 같다면 카운트
3. 현재 부분합이 M보다 작으면 end를 1 증가
4. 현재 부분합이 M보다 크거나 같으면 start를 증가
5. 모든 경우를 확인할때까지 2~4번 과정을 반복

- 시작점을 오른쪽으로 이동시키면 항상 합이 감소하고, 끝점을 오른쪽으로 이동시키면 항상 합이 증가하기때문에 투포인터 알고리즘으로 해결할 수 있음
- 만약 리스트 내 음수 데이터가 존재한다면 투포인터 알고리즘으로 해결 불가

### 정렬되어 있는 두 리스트의 합집합

> 이미 정렬되어 있는 2개의 리스트의 모든 원소를 합쳐서 정렬한 결과를 계산하는 문제

1. 정렬된 리스트 A와 B를 입력받음
2. 리스트 A에서 처리되지 않은 원소 중 가장 작은 원소를 i가 가리키도록 함
3. 리스트 B에서 처리되지 않은 원소 중 가장 작은 원소를 j가 가리키도록 함
4. A[i]와 B[j]중에서 더 작은 원소를 결과 리스트에 담음
5. 리스트 A와 B에서 더 이상 처리할 원소가 없을때까지 2~4번 과정을 반복

- 2개의 포인터를 이용하여 각 리스트에서 처리되지 않은 원소 중 가장 작은 원소를 가리킴
- 리스트 A의 길이가 N, 리스트 B의 길이가 M일때 시간복잡도는 $O(N+M)$ (단순히 각 리스트의 모든 원소를 한번씩만 순회)
- 정렬되어 있는 두 리스트의 합집합 알고리즘은 <strong>병합 정렬과 같은 일부 알고리즘에서 사용됨</strong>

---

## 구간 합 계산

> 연속적으로 나열된 N개의 수가 있을때, 특정 구간의 모든 수를 합한 값을 구하는 문제

- 구간 합 계산 문제는 여러개의 쿼리로 구성되는 문제 형태로 출제되는 경우가 많음 (다수의 구간에 대해서 합을 각각 구하기)
- M개의 쿼리가 주어졌을때, 모든 쿼리에 대하여 구간합을 출력하는 문제가 전형적인 형태
- 매번 구간합을 계산한다면 $O(NM)$의 시간복잡도
  - M개의 쿼리가 수행될때마다 전체 리스트의 구간합 계산
- 데이터의 수가 많으면 $O(NM)$으로 해결 불가 -> 여러번 사용될만한 정보는 미리 구해 저장해놓으면 유리
- <strong>N개의 수에 대해서 어떠한 '처리'를 수행한 뒤에 나중에 M개의 쿼리가 각각 주어질때마다 빠르게 구간합을 도출할 수 있도록 하자</strong>

### 접두사 합

> 리스트의 맨 앞부터 특정 위치까지의 합을 구해 놓은 것

- 구간 합 계산을 위해 가장 많이 사용되는 기법
- N개의 수의 위치 각각에 대하여 접두사합을 미리 구해놓으면 각 쿼리에 대해 빠르게 구간 합 계산 가능

1. N개의 수에 대하여 접두사합을 계산하여 배열 P에 저장
2. 매 M개의 쿼리 정보 [L, R]을 확인할 때, 구간합은 <strong>P[R]-P[L-1]</strong>

N개의 데이터와 M개의 쿼리가 있을 때 전체 구간합을 모두 계산하는 작업은 $O(N+M)$의 시간복잡도를 가짐 (매 쿼리당 계산시간은 $O(1)$)
